/**
 * @copyright 2015 Chris Stylianou
 * @copyright 2007 - 2008 Kai Winter
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

// Qt includes.
#include <QtCore/QDir>
#include <QtNetwork/QNetworkProxy>
#include <QtWidgets/QWidget>

// STL includes.
#include <chrono>
#include <mutex>

// Local includes.
#include "qwidgetmap_global.h"
#include "EventManager.h"
#include "LayerManager.h"
#include "RenderManager.h"
#include "ViewportManager.h"

/// QWidgetMap namespace.
namespace qwm
{

    /// Autogenerated UI namespace.
    namespace Ui
    {
        // Forward-declare the UI.
        class QWidgetMap;
    }

    /**
     * Top-level widget to use/inherit within your application.
     */
    class QWIDGETMAP_EXPORT QWidgetMap : public QWidget
    {
        Q_OBJECT

    public:

        /**
         * QWidgetMap constructor.
         * @param size_px The size of the widget in pixels.
         * @param parent QObject parent ownership.
         * @param window_flags QWidget window flags.
         */
        explicit QWidgetMap(const QSizeF& size_px, QWidget* parent = nullptr, Qt::WindowFlags window_flags = 0);

        /**
         * QWidget constructor of QWidgetMap for use with QtDesigner.
         * @param parent QObject parent ownership.
         * @param window_flags QWidget window flags.
         */
        explicit QWidgetMap(QWidget* parent = nullptr, Qt::WindowFlags window_flags = 0)
            : QWidgetMap(parent->size(), parent, window_flags) { }

        /// Disable copy constructor.
        QWidgetMap(const QWidgetMap&) = delete;

        /// Disable copy assignment.
        QWidgetMap& operator=(const QWidgetMap&) = delete;

        /// Destructor.
        ~QWidgetMap();

    public:

        /**
         * Fetches the viewport manager.
         * @return the viewport manager.
         */
        ViewportManager& viewport_manager();

        /**
         * Fetches the layer manager.
         * @return the layer manager.
         */
        LayerManager& layer_manager();

        /**
         * Fetches the event manager.
         * @return the event manager.
         */
        EventManager& event_manager();

        /**
         * Set the widget size in pixels.
         * @param size_px The widget size in pixels.
         */
        void setSize(const QSizeF& size_px);

        /**
         * Sets the proxy for HTTP connections.
         * @param proxy The proxy details.
         */
        void setNetworkProxy(const QNetworkProxy& proxy);

        /**
         * Enable persistent caching of map tiles.
         * Call this method to allow the QWidgetMap widget to save map tiles persistent (also over application restarts).
         * Default: Images are stored in the subdirectory "QWidgetMap.cache" within the user's home directory.
         * @param path The path where the images should be stored.
         * @param expiry The max age (in minutes) of an image before its removed and a new one is requested (0 to keep forever).
         */
        void enablePersistentCache(const std::chrono::minutes& expiry = std::chrono::minutes(0), const QDir& path = QDir::homePath() + QDir::separator() + "QWidgetMap.cache");

        /**
         * Set the background colour of the map control.
         * @param colour The background colour to set.
         */
        void setBackgroundColour(const QColor& colour = Qt::transparent);

        /**
         * Set whether to show the scaled primary screen during viewport changes.
         * @param visible Whether the scaled primary screen should be displayed.
         */
        void enableScaledPrimaryScreen(const bool& visible);

        /**
         * Set whether the crosshairs should be displayed at the focus point.
         * @param visible Whether the crosshairs should be displayed.
         */
        void enableFocusPointCrosshairs(const bool& visible);

        /**
         * Set whether the zoom controls should be displayed.
         * @param enable Whether the zoom control should be displayed.
         * @param align_left Whether to align the zoom controls to left or right of the widget.
         */
        void enableZoomControls(const bool& enable, const bool& align_left = true);

        /**
         * Fetch the primary screen pixmap.
         * @return the primary screen pixmap.
         */
        QPixmap primaryScreen() const;

    private:

        /**
         * Updates the zoom/progress indicator controls.
         */
        void updateUI();

        /**
         * Draw the primary screen and "auto-moving" geometries to the pixmap.
         * @param painter The painter to draw on.
         * @param viewport The viewport to use.
         */
        void drawPrimaryScreen(QPainter& painter, const Viewport& viewport) const;

        /**
         * Checks whether the current primary screen is still valid for the visible viewport.
         * If invalid, it requests a redraw from the render manager.
         * @param viewport The viewport to use.
         */
        void checkPrimaryScreen(const Viewport& viewport);

        /**
         * Called when the render manager has an updated pixmap available.
         * @param pixmap The updated pixmap.
         * @param rect_world_coord The rect of the updated pixmap in world coordinates.
         * @param zoom The zoom level of the updated pixmap.
         */
        void updatePrimaryScreen(QPixmap pixmap, util::RectWorldCoord rect_world_coord, int zoom);

        /**
         * Clears the scaled primary screen.
         */
        void clearScaledPrimaryScreen();

        /**
         * Called by QWidget to redraw the current view to the QWidget display.
         * @param paint_event The paint event.
         */
        void paintEvent(QPaintEvent* paint_event);

    private:

        /// UI form.
        std::unique_ptr<Ui::QWidgetMap> m_ui;

        /// Layer manager.
        std::shared_ptr<LayerManager> m_layer_manager;

        /// Viewport manager.
        std::shared_ptr<ViewportManager> m_viewport_manager;

        /// Event manager.
        EventManager m_event_manager;

        /// Render manager.
        RenderManager m_render_manager;

    private:

        /// Mutex to protect the primary screen usage.
        mutable std::mutex m_mutex_primary_screen;

        /// Primary screen pixmap (always 2 x viewport size to allow for panning backbuffer).
        QPixmap m_primary_screen_pixmap;

        /// The rect of the current primary screen in world coordinates.
        util::RectWorldCoord m_primary_screen_rect_world_coord { util::PointWorldCoord { 0.0, 0.0 },  util::PointWorldCoord { 0.0, 0.0 } };

        /// The zoom level of the current primary screen.
        int m_primary_screen_zoom { 0 };

        /// Whether to show the scaled primary screen during viewport changes.
        bool m_scaled_primary_screen_enabled { true };

        /// Scaled primary screen pixmap (updated when the primary screen's and current viewport's zoom levels differ).
        mutable QPixmap m_scaled_primary_screen_pixmap;

        /// The rect of the scaled primary screen in world coordinates (updated when the primary screen's and current viewport's zoom levels differ).
        mutable util::RectWorldCoord m_scaled_primary_screen_rect_world_coord { util::PointWorldCoord { 0.0, 0.0 },  util::PointWorldCoord { 0.0, 0.0 } };

        /// Whether the crossharis should be visible.
        bool m_crosshairs_enabled { true };

        /// Whether to align the zoom controls to the left (or right).
        bool m_control_zoom_align_left { true };

    };

}
